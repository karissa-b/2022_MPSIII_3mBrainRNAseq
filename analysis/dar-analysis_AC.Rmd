---
title: "DAR Analysis"
subtitle: "2022_MPSIII_3mBrainRNAseq dataset - AC comparison"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  workflowr::wflow_html:
    theme: flatly
    toc: true
    toc_float: true
    toc_depth: 4
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE,
  fig.align = "center"
)
```

# Setup

Load libraries and set global options.

```{r packages}
suppressPackageStartupMessages({
  ## Common
  library(tidyverse)
  library(magrittr)
  library(here)
  library(AnnotationHub)
  library(purrr)
  library(scales)
  library(kableExtra)
  # library(tictoc)  # Causes a bug in rowRanges()
  library(ggrepel)
  library(RColorBrewer)
  library(ggpubr)
  library(pander)
  library(rmarkdown)
  library(viridis)
  ## Project specific
  library(VariantAnnotation)
  library(Gviz)
  library(zoo)
  library(msigdbr)
  library(readxl)
  library(limma)
})
```

An R package for DAR analysis is currently under development and will be used for the following analysis.
The core functionally of the package is complete (as of 21/06/23). 
However some subtleties may change and new features will be added as its developmentment progresses.
This means some of the following code may break, but a simple fix that produces the same results will always exist.
To install the package while it is still in development, uncomment the code in the chunk below.

```{r darr}
# BiocManager::install("baerlachlan/darr")
library(darr)
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
```

```{r opts}
# By default Gviz expects UCSC chromosome names
# We're working with Ensembl so let's turn this off
options(ucscChromosomeNames = FALSE)
```

## Introduction

This document contains the Differential Allelic Representation (DAR) analysis for the MPS-III A/B arm of the experiment.

## EnsDb

```{r ensParams}
ens_species <- "Danio rerio"
ens_release <- "101"
ens_assembly <- "GRCz11"
```

Grab genome feature annotations for `r ens_species` Ensembl release `r ens_release` (genome assembly `r ens_assembly`).

```{r ensDb}
ah <- AnnotationHub() %>%
  subset(species == ens_species) %>%
  subset(rdataclass == "EnsDb")
ahId <- ah$ah_id[str_detect(ah$title, ens_release)]
ensDb <- ah[[ahId]]
```

```{r chrInfo}
# Filter for primary chromosomes
chrInfo <- getChromInfoFromEnsembl(ens_assembly, release = ens_release) %>%
  dplyr::filter(coord_system == "chromosome")
primary_chrs <- chrInfo$name
```

```{r genes}
genes <- genes(ensDb, filter = SeqNameFilter(primary_chrs))
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
]
```

## Metadata

Load and clean the sample metadata by renaming columns following `R` naming conventions and setting categorical variables as factors.
Also append sample file basenames from a file I created (`data/sample_basenames.csv`), as we will need these later.
This metadata contains information for all samples in the experiment, so let's filter for only samples in the A/B dataset.

```{r experiment_arm}
expArm <- "AC"
```

```{r metadata}
metadata <- read_xlsx(here("data/meta_final.xlsx")) %>%
  dplyr::rename(
    rin = RIN,
    sex = Sex,
    rna_batch = rnaBatch,
    mps = MPS,
    uln = ULN,
    home_tank = `Home tank`,
    dob = DOB,
    death = Death
  ) %>%
  mutate(
    sex = as.factor(sex),
    genotype = case_when(
      genotype == "wt" ~ "WT", 
      genotype == "het" ~ "sgsh_het",
      genotype == "naglu" ~ "MPSIIIB", 
      genotype == "sgsh" ~ "MPSIIIA",
      genotype == "hgsnat" ~ "MPSIIIC"
    ),
    genotype = as.factor(genotype),
    home_tank = as.factor(home_tank)
  ) %>%
  left_join(read_csv(here("data/sample_basenames.csv"))) %>%
  dplyr::filter(mps == expArm) %>%
  droplevels()
```

```{r metadataVis}
metadata %>%
  kable(
    align = "l",
    caption = "Sample metadata for the MPS-III A/C arm of the experiment"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Set up colours for plotting by genotype.
Going with a colourblind-friendly palette (`Set2`) for best accessibility.

```{r genoCols}
genoCols <- metadata$genotype %>%
  levels() %>%
  length() %>%
  brewer.pal("Set2") %>%
  setNames(levels(metadata$genotype))
```

# DE data

Load in the `dgeList` and `topTable`s from Karissa's DE analysis.

```{r dgeList}
dgeList <- readRDS(here("data/R_objects/dge_bc.rds"))
```

```{r topTables}
topTables <- readRDS(here("data/R_objects/toptab_ac_cqn.rds"))
```

Also pull the gene IDs for DE genes.

```{r}
deGenes <- sapply(topTables, function(x){
  dplyr::filter(x, DE) %>%
    pull(gene_id)
}, simplify = FALSE)
```

# Differential Allelic Representation

DAR analysis is performed using genotype calls from variant calling software.
Here the `GATK` best practices workflow for RNAseq short variant discovery was followed to produce a multi-sample `VCF` file containing information for any single nucleotide locus that varied in at least one sample.
Note that specific filters were applied to only select loci with considerable evidence for variation (see the Snakemake workflow in this repository for more information).

## Genotypes

Genotype data from the `VCF` file is parsed into a `GRanges` class object using the `darr` package.
This file is large and therefore does not exist in the Git repository.
Phasing information is also removed when reading the genotypes as it is not required for DAR analysis and complicates downstream processing.

```{r genotypes}
vcf_path <- file.path(
  "/hpcfs/users/a1647910/2022_MPSIII_3mBrainRNAseq/code",
  "analysis-variants_AC/results/09_variants/6_select/all_samples.vcf.gz"
)
genotypes <- readGenotypes(
  file = vcf_path,
  unphase = TRUE,
  genome = genome(ensDb)
)
```

Genotypes are reported as numeric indices.
`0` indicates the reference allele, `1` is the first alternate allele, `2` is the second alternate allele, and so on.
For DAR analysis, we work directly with the indices as they are consistent across all samples for a single variant position.

## Allele counts

We aim to calculate a DAR metric at each suitable variant locus.
This requires us to firstly summarise the genotype data into counts of the alleles reported at each variant locus.
First we define our sample grouping structure as a `list`, where each element contains a character vector of samples within a single group.

```{r samplesByGroup}
samplesByGroup <- metadata %>%
  split(f = .$genotype) %>%
  sapply(function(x){
    pull(x, basename)
  }, simplify = FALSE)
```

Now at each locus we can count the number of alleles that exist within the groups.
This returns a `GRangesList` with each element corresponding to a different sample group.

```{r alleleCounts}
alleleCounts <- countAlleles(genotypes = genotypes, groups = samplesByGroup)
```

## Normalisation

Not all samples have genotype calls, so we normalise by converting the allele counts into a proportion of total counts at each locus.
We also filter variant loci independently within each sample group with the default criterion: number of samples with called genotypes > number of samples with missing genotypes.

```{r alleleProps}
alleleProps <- countsToProps(counts = alleleCounts, filter = TRUE)
```

## DAR

Now that we have normalised values of allelic representation at each variant locus within our sample groups, we can calculate the DAR metric between groups.
Firstly, we define our contrasts of interest.

```{r contrasts}
contrasts <- makeContrasts(
  A_vs_WT = MPSIIIA - WT,
  C_vs_WT = MPSIIIC - WT,
  levels = names(alleleProps)
)
```

DAR is calculated by firstly determining the Euclidean distance between allelic proportions of the contrasted sample groups.
The Euclidean distance is then converted to the DAR metric by dividing by $$\sqrt{2}$$, resulting in an easy-to-interpret value between 0 and 1, where 0 represents identical allelic representation and 1 represents complete diversity.
This is handled within the `dar()` function by passing our allelic proportions and intended contrasts as arguments.

Two types of DAR values are reported by the `dar()` function as metadata columns of the resulting `GRanges` objects:

- `dar_origin`: The raw DAR values calculated at single nucleotide positions (the origin) between sample groups.
This represents a DAR estimate at a precise locus.
- `dar_region`: The mean of raw DAR values in a region surrounding the origin. 
The size of the region is controlled using the `winSize` argument, which establishes an elastic sliding window to average the specified number of dar_origin values.
This represents a DAR estimate for the genomic region surrounding the origin locus. 

```{r winSize}
winSize <- 5
```

With a chosen elastic window size of `r winSize` loci, this will smooth the DAR metric at each origin locus with the DAR values of the `r (winSize - 1) / 2` loci either side.

```{r dar}
dar <- dar(props = alleleProps, contrasts = contrasts, winSize = winSize)
```

We now have DAR values for the common loci between the two sample groups in each contrast.
Each element of the resulting `GRangesList` object represents a single contrast and are named as defined in our `contrasts` object.

## DAR ECDF

Plotting the empirical cumulative distribution function of DAR by chromosome is useful to determine whether the mutant chromosome contains higher DAR relative to other chromosomes.
Here we highlight the chromosome containing the mutation to visually identify if this is the case.
The *sgsh* gene implicated with MPS-IIIA is located on chromosome 22.
The *hgsnat* gene implicated with MPS-IIIB is located on chromosome 1.

```{r darECDF_A_chr22}
plotDarECDF(dar$A_vs_WT, darVal = "region", highlight = "22") +
  scale_colour_manual(values = c("red", "grey")) +
  labs(title = "MPSIIIA vs WT")
```

This dataset provides an interesting scenario where samples were genotyped at both the *sgsh* and *hgsnat* loci.
Samples within the MPS-IIIA experimental groups were selected so that they were wildtype at the *hgsnat* locus.
All samples in the dataset originated from a single cross of double heterozygous parents, meaning that all samples in the MPS-IIIA experimental groups should share identical wildtype homologues of chromosome 1 (the chromosome of the *hgsnat* locus), disregarding recombination.
This means that chromosome 1 should display relatively low DAR in the MPS-IIIA comparisons, so let's take a look.

```{r darECDF_A_chr1}
plotDarECDF(dar$A_vs_WT, darVal = "region", highlight = "1") +
  scale_colour_manual(values = c("red", "grey")) +
  labs(title = "MPSIIIA vs WT")
```

Chromosome 1 does indeed have very low DAR relative to the other chromosomes.
This contributes evidence to the argument that genotype-based selection of samples is a key driver of DAR outcomes in RNA-seq experiments.

An analogous situation is present in the MPS-IIIC samples, where the samples should share near-identical wildtype homologues of chromosome 22.
Let's take a look at both.

```{r darECDF_C_chr1}
plotDarECDF(dar$C_vs_WT, darVal = "region", highlight = "1") +
  scale_colour_manual(values = c("red", "grey")) +
  labs(title = "MPSIIIC vs WT")
```

```{r darECDF_C_chr22}
plotDarECDF(dar$C_vs_WT, darVal = "region", highlight = "22") +
  scale_colour_manual(values = c("red", "grey")) +
  labs(title = "MPSIIIC vs WT")
```

Again we see relatively high DAR on the mutant chromosome (1), and relatively low DAR on the wildtype controlled chromosome (22).

From these plots we can predict that for each comparison, an overrepresentation of DE genes may exist on the respective mutant chromosomes, due to the potential of eQTL differences.
However, the controlled wildtype chromosomes should exhibit far less of these false positives due to low DAR.

## DEG-DAR relationship

We can produce a localised visualisation to assess whether differentially expressed genes (DEG) may be prone eQTL artefacts by plotting the trend in DAR along a chromosomal axis and overlaying the position of DEGs.
This functionality has not yet been implemented in the `darr` package, so let's define a function here instead.

```{r plotChrDar}
plotChrDar <- function(
    dar, chromosome, features = GRanges(), foi = GRanges(),
    darType = "b", highlight_features = TRUE,
    title = ""
){
  tracks <- list()
  
  if (length(foi)) {
    foi <- foi %>%
      plyranges::filter(seqnames == chromosome) %>%
      plyranges::mutate(symbol = gene_name)
    foi_track <- GeneRegionTrack(
      range = foi,
      transcriptAnnotation = "symbol",
      col = "white",
      fill = "white",
      showTranscriptId = TRUE,
      fontcolor.group = "red",
      cex.group = 0.6,
      size = 0.5,
      name = NULL
    )
    tracks <- append(tracks, foi_track)
  }
  
  axis_track <- GenomeAxisTrack(
    add53 = TRUE,
    add35 = TRUE,
    name = paste0("Chr", chromosome),
    showTitle = TRUE,
    size = 1
  )
  if (length(foi)) {
    axis_track <- HighlightTrack(
      trackList = list(axis_track),
      range = foi
    )
  }
  tracks <- append(tracks, axis_track)
  
  if (length(features)) {
    features <- features %>%
      plyranges::filter(seqnames == chromosome) %>%
      plyranges::mutate(symbol = gene_name)
    features_track <- AnnotationTrack(
      range = features,
      name = "DE",
      shape = "box",
      fill = "darkgray",
      group = features$gene_name,
      groupAnnotation = "group",
      fontcolor.group = 1,
      cex.group = 0.6,
      size = 0.4
    )
    tracks <- append(tracks, features_track)
  }
  
  dar_track <- dar[,"dar_region"] %>%
    plyranges::filter(seqnames == chromosome) %>%
    DataTrack(
      type = darType,
      name = "DAR",
      size = 8,
      window = -1,
      windowSize = 1,
      cex = 0.4,
      col = "grey20",
      col.axis = "black",
      yTicksAt = seq(0, 1, 0.1),
      ylim = c(0, 1)
    )
  if (highlight_features) {
    if (all(length(features) & length(foi))) {
      ranges <- c(features, foi)
    } else if (length(features)) {
      ranges <- features
    } else if (length(foi)) {
      ranges <- foi
    } else {
      ranges <- GRanges()
    }
    dar_track <- HighlightTrack(
      trackList = list(dar_track),
      range = ranges,
      col = c(rep("#ffe0e0", length(features)), rep("red", length(foi))),
      fill = c(rep("#ffe0e0", length(features)), rep("red", length(foi)))
    )
  }
  tracks <- append(tracks, dar_track)
  
  plotTracks(
    trackList = tracks,
    main = title,
    cex.main = 1,
    cex.title = 0.6,
    col.title = "black",
    background.title = "white"
  )
}
```

### MPS-IIIA

First let's look at the mutant chromosome, as this was identified as having the highest average DAR from the ECDF we plotted above.

```{r chrDar_A_chr22}
plotChrDar(
  dar = dar$A_vs_WT,
  chromosome = "22",
  features = genes[genes$gene_id %in% deGenes$`MPS-IIIA`],
  foi = genes[genes$gene_name == "sgsh"]
)
```

And comparing this to the controlled wildtype chromosome 1:

```{r chrDar_A_chr24}
plotChrDar(
  dar = dar$A_vs_WT,
  chromosome = "1",
  features = genes[genes$gene_id %in% deGenes$`MPS-IIIA`]
)
```

### MPS-IIIC

The mutant chromosome also showed high DAR in the MPS-IIIC vs. WT comparison.

```{r chrDar_B_chr24}
plotChrDar(
  dar = dar$C_vs_WT,
  chromosome = "1",
  features = genes[genes$gene_id %in% deGenes$`MPS-IIIC`],
  foi = genes[genes$gene_name == "hgsnat"]
)
```

Again comparing to the controlled wildtype chromosome 22:

```{r chrDar_B_chr22}
plotChrDar(
  dar = dar$C_vs_WT,
  chromosome = "22",
  features = genes[genes$gene_id %in% deGenes$`MPS-IIIC`]
)
```

## Assign gene DAR

We can assign DAR values to genes within the dataset to provide an estimate of the potential for a gene's expression to be impacted by eQTLs.
eQTLs don't necessarily exist within the gene itself, so it is preferable to use smoothed DAR values (`dar_region` metadata column in the `dar` object) as an estimate of DAR within a region.
First we need to convert the ranges of our `dar` object to represent regions.
Here we also extend the edge ranges of each chromosome to encompass the entire chromosome, such that genes in these regions also get assigned a DAR value.

```{r darRegions}
darRegions <- convertRanges(dar, extendEdges = TRUE)
```

```{r geneDar}
geneDar <- assignFeatureDar(genes, darRegions, darVal = "region")
```

We will save these assigned values for use in further analysis.

```{r saveGeneDar}
geneDar_path <- file.path(here("data/dar-analysis"), expArm, "geneDar.Rds")
saveRDS(geneDar, geneDar_path)
```
